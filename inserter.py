import gc
import logging
from pprint import pprint

class HashLevel(list):
    totalNum = 0

class Inserter:
    finalizing = False
    maximumPieceSize = 0xffff
    def __init__(self,keyLength,graph=None):
        self.levels = []
        self.graph = graph
        self.keyLength = keyLength
        self.keysPerPiece = int(self.maximumPieceSize / self.keyLength)
    def __iadd__(self,key):
        self.addLevel(key,0)
        return self
    def addLevel(self,key,level):
        logging.info("Kl{} {}".format(key,level))
        if len(self.levels) == level:
            self.levels.append(HashLevel())
        # make room for the key first
        bottom = self.maybeCarry(level)
        bottom.append(key)
        bottom.totalNum += 1
        return bottom
    def maybeCarry(self,level):
        platform = self.levels[level]
        if ( self.finalizing and len(platform) > 1 ) or ( len(platform) == self.keysPerPiece ):
            ctr = platform.totalNum
            newkey = self.insertPiece(b''.join(platform),ctr,level)
            if self.graph:
                for hash in platform:
                    self.graph.update(newkey,hash)
            platform.clear()
            finalizing = self.finalizing
            if finalizing:
                self.finalizing = False
            platform = self.addLevel(newkey,level+1)
            if finalizing:
                self.finalizing = True
        return platform
    def finish(self):
        self.finalizing = True
        platform = None
        depth = len(self.levels)
        for level in range(depth):
            platform = self.maybeCarry(level)
            if len(platform) == 1: break
        pprint(self.levels)
        assert platform
        result = platform[0]
        self.levels = []
        gc.collect()
        return result,depth
    def insertPiece(self,piece,ctr,level):
        raise NotImplementedError("Override this to insert pieces upon request, not just the pieces passed to +=! Also the pieces generated by carrying.")


