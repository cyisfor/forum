import gc

class HashLevel(list):
    totalNum = 0

class Inserter:
    finalizing = False
    maximumPieceSize = 0xffff
    def __init__(self,keyLength):
        self.levels = []
        self.keyLength = keyLength
        self.keysPerPiece = int(self.maximumPieceSize / self.keyLength)
    def __iadd__(self,key):
        self.addLevel(key,0)
        return self
    def addLevel(self,key,level):
        if len(self.levels) == level:
            self.levels.append(HashLevel())
        # make room for the key first
        bottom = self.maybeCarry(level)
        bottom.append(key)
        bottom.totalNum += 1
    def maybeCarry(self,level):
        platform = self.levels[level]
        if ( self.finalizing and len(platform) > 1 ) or ( len(platform) == self.keysPerPiece ):
            ctr = platform.totalNum
            newkey = self.insertPiece(b''.join(platform),ctr,level)
            platform.clear()
            finalizing = self.finalizing
            if finalizing:
                self.finalizing = False
            self.addLevel(newkey,level+1)
            if finalizing:
                self.finalizing = True
        return platform
    def finish(self):
        self.finalizing = True
        platform = None
        depth = len(self.levels)
        for level in range(depth):
            platform = self.maybeCarry(level)
            if len(platform) == 1: break
        assert not platform is None
        result = platform[0]
        self.levels = []
        gc.collect()
    def insertPiece(self,piece,ctr,level):
        raise NotImplementedError("Override this to insert pieces upon request, not just the pieces passed to +=! Also the pieces generated by carrying.")


